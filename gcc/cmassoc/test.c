/*
 * Copyright (c) 2010, Atheros Communications Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


/* masterd - master daemon program.
 * This program manages the system as a whole, including invoking
 *      other daemon programs as needed.
 *
 *                                      Author: Ted Merrill, August 2008
 *
 * Before compiling this file, you need to have done the following:
 * -- Built the tools 
 * -- Built the library so that the header files are auto-extracted
 *      and thus available for use.
 * -- Provided a mib definition file "gwmib.mib" and built it
 *      into autogenerated mib header file and data in
 *      gwmib.amibh and gwmib.amibc etc. ....
 *      built with the prefix "gwmib", thus producing a global
 *      data called gwmibMibTable.
 *
 * Environmental variables
 * MASTERD_DBG_LEVELS -- use in preference to DBG_LEVELS, see libath/dbg.c
 *      example:
 *              export MASTERD_DBG_LEVELS=all=info,child=err
 *              masterd&
 * MASTERD_INIT_ONLY -- hex value for masterd "InitList"
 *      which can be used to suppress some module initializations.
 *      MASTERD_INIT_SKIP is easier.
 * MASTERD_INIT_SKIP -- hex value of bits to remove from masterd "InitList"
 *      which can be used to suppress some module initializations.
 *      Refer to masterdMain.c source code.
 *
 * Program arguments:
 *      -d {<module>=<level>}[,<module>=<level>]...   -- configure debug messages
 *      -w  -- fork with parent watchdog watching and restarting child worker
 *      -w<program> -- Like -w but exec <program> if child worker dies
 *              E.g. : -wreboot exec's reboot on child death.
 *      --daemonize    -- run in the background, detaching from terminal
 *              (do not mix -w and --daemonize)
 */

/* C library and Linux includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>

/* gateway configuration header (auto-generated).
*       This must precede our other headers.
*/
#include <gatewayconfig.h>

/* libath and other base header files */
#include <evloop.h>     /* Main event loop */
#include <dbg.h>        /* Debug messagse */
#include <mib.h>        /* Generic MIB handling */
#include <csh.h>        /* command (debugging) shell */
#include <cmd.h>        /* command menu system */
#include <signalExit.h> /* signal handling */
#include <service.h>    /* inter-handler signalling */
#include <gwmib.h>      /* our MIB */
#if GATEWAY_TR069
#include <ev69.h>       /* tr-069 style event handling */
#endif
#include <filexfer.h>   /* File upload/download */
#if GATEWAY_FIRMWARE
#include <firmware.h>
#endif
#if GATEWAY_FILEXFER_STORE
#include <filexferStore.h>      /* nonvolatile storage of filexfer q */
#endif

/* Management plugins (alphabetical order, please) */
#include <mibcli.h>     /* For debugging only */
#include <mibsh.h>      /* Simple mib control shell */
#if GATEWAY_NVS_MTD
#include <nvsmtd.h>     /* Non-volatile storage, using Linux MTD */
#else
#include <nvs.h>        /* Non-volatile storage, basic */
#endif
#if GATEWAY_TR069
#include <tr069sh.h>    /* tr069 management protocol */
#endif  // GATEWAY_TR069

#if GATEWAY_CTCMW
#include <ctcmw.h>    /* ctc-middleware management protocol */
#endif  // GATEWAY_CTCMW

#if GATEWAY_USB
#include <usb_service.h>
#endif  // GATEWAY_USB

/* Service plugins (alphabetical order, please) */
#if GATEWAY_TIME
#include <settime.h>    /* Time zone configuration */
#include <timezone.h>   /* Set clock time using e.g. network time protocol */
#endif
#include <wan.h>        /* Wide Area Network connection management */
#if !GATEWAY_NO_WLAN
#include <wlan_service.h> /* Wireless Local Area Network management */
#include <wlansec.h>    /*Wireless Local Area Network Security Options*/
#endif // !GATEWAY_NO_WLAN
#include <lan.h>        /* Local Area Network connection management */
#include <brouting.h>
#if GATEWAY_DHCP_SERVER
#include <dhcpsvr.h>
#endif
#if GATEWAY_PPPOE_PROXY
#include <pppoeproxy.h> /* PPPoE Proxy service plug-in */
#endif
#if GATEWAY_SYSLOG
#include <syslog_service.h>
#endif
#if GATEWAY_IGMP
#include <igmp.h>
#endif
#if GATEWAY_SERVICE_MANAGE
#include <servicemanage.h>
#endif
#if GATEWAY_QOS
#include <qos.h>
#endif
#if GATEWAY_UPNP
#include <upnp.h>
#endif
#if GATEWAY_LLTD
#include <lltd.h>
#endif
#if GATEWAY_ROUTING
#include <router.h>
#endif
#if GATEWAY_DEV_INFO
#include <devinfo.h>
#endif
#if GATEWAY_PASSWORD
#include <password.h>
#endif
#if GATEWAY_DIAG
#include <diag.h>
#endif
#if GATEWAY_SWITCH_QOS
#include <switchqos.h>
#endif
#if GATEWAY_PHONE
#include <phone.h>
#endif
#if GATEWAY_PROFILE_PLC
#include <plc.h>
#endif 

#ifdef GATEWAY_IPV6_MODULE
#if GATEWAY_RADVD
#include <radvd.h>
#endif
#if GATEWAY_DHCP6S
#include <dhcp6s.h>
#endif
#if GATEWAY_PPPDHCP6C
#include <pppdhcp6c.h>
#endif
#if GATEWAY_ICMPV6
#include <icmpv6.h>
#endif
#if GATEWAY_TSPC
#include <tspc.h>
#endif
#if GATEWAY_IVI
#include <ivi.h>
#endif
#endif //GATEWAY_IPV6_MODULE
#if GATEWAY_OSPFD
#include <ospfd.h>
#endif  // GATEWAY_OSPFD
#if GATEWAY_ART
#include <art.h>
#endif  // GATEWAY_ART
#if GATEWAY_PROFILE_HY
#include <hy.h>
#endif
#if GATEWAY_WSPLC
#include <wsplc.h>
#endif
/* Debugging options */
/*private*/ const struct dbgInitOptions masterdDbgInitOptions = {
    .ProgramName = "MSTR",
    .EnvName = "MASTERD_DBG_LEVELS",
};

/* Location of database file */
#ifdef GATEWAY_DBFILE_PATH
#define DBFILE GATEWAY_DBFILE_PATH
#else
#define DBFILE "/etc/gwmib.mibdb"
#endif

#if GATEWAY_NVS_MTD
#else   // GATEWAY_NVS_MTD
/* Nonvolatile storage options */
/*static*/ /*const?*/ struct nvsOptions masterdNvsOptions = {
    .FilePath = DBFILE,
};
#endif  // GATEWAY_NVS_MTD

/* Debug convenience feature allows omitting the initialization
*       of some modules... be aware that this can create problems
*       if other modules (which are initialized) depend upon modules
*       which are not initialized.
*
*       THESE DO NOT HAVE TO BE IN ANY PARTICULAR ORDER.
*/
enum masterdInitListEnum {
    masterdInit_broutingInit = 0,
    masterdInit_cshInit = 1,
    masterdInit_dhcpdInit = 2,
    masterdInit_igmpInit = 3,
    masterdInit_lanInit = 4,
    masterdInit_mibcliInit = 5,
    masterdInit_mibshInit = 6,
    masterdInit_nvsInit = 7,
    masterdInit_pppoeproxyInit = 8,
    masterdInit_serviceManageInit = 9,
    masterdInit_settimeInit = 10,
    masterdInit_syslogInit = 11,
    masterdInit_timezoneInit = 12,
    masterdInit_tr069shInit = 13,
    masterdInit_usbInit = 14,
    masterdInit_wanInit = 15,
    masterdInit_wlanInit = 16,
    masterdInit_wlansecInit = 17,
    masterdInit_qosInit = 18,
    masterdInit_upnpInit = 19,
    masterdInit_routerInit = 20,
    masterdInit_devinfoInit = 21,
    masterdInit_passwordInit = 22,
    masterdInit_diagInit = 23,
    masterdInit_firmwareInit = 24,
    masterdInit_ctcmwInit = 25,
    masterdInit_switchqosInit = 26,
    masterdInit_phoneInit = 27,
    masterdInit_lltdInit = 28,
    masterdInit_plcInit = 29,

#ifdef GATEWAY_IPV6_MODULE    
    //masterdInit_radvdInit = 29,    
    //masterdInit_dhcp6sInit = 30,  
    //masterdInit_pppdhcp6cInit = 31,    
#endif //GATEWAY_IPV6_MODULE     
};

/* State info for masterd main level */
/*private*/ struct {
    struct dbgModule *DebugModule;
    char **SaveArgv;    /* for re-exec */
    /* If DoWatch is non-empty string, the it is program to be exec'd
    *   after death of worker child instead of restarting worker child.
    */
    char *DoWatch;      /* fork, wait and restart child to ensure upness */
    int DoDaemonize;    /* detach from parent */
    int RebootRequired;
    unsigned InitList;   /* bits indexed by enum masterdInitListEnum */
    int DoWatchPid;     /* if we are parent, process id we watch */
} masterdS;

#define masterdDebug(level, ...) \
        dbgf(masterdS.DebugModule,(level),__VA_ARGS__)


/* called from exit()
 */
/*private*/ void masterdExitHandler(void)
{
    masterdDebug(DBGINFO, "ENTER masterdExitHandler");
    if (masterdS.RebootRequired) {
        #if GATEWAY_REAL_REBOOT
        if (fork() == 0)
            execlp("reboot", "reboot", NULL);
        sleep(60);      /* give reboot a chance to happen */
        #endif
    }
    if (masterdS.DoWatchPid > 0) {
        masterdDebug(DBGINFO, "Killing child masterd pid=%d",
            masterdS.DoWatchPid);
        kill(-masterdS.DoWatchPid, SIGKILL); /* negative to kill process group */
        kill(masterdS.DoWatchPid, SIGKILL);  /* just in case */
        masterdS.DoWatchPid = 0;
    }
    masterdDebug(DBGINFO, "LEAVE masterdExitHandler");
}

/* called from mib module when a reboot is required
 */
/*private*/ void masterdRebootHandlerFromMib(void)
{
    masterdDebug(DBGINFO, "masterd reboot ... scheduled!!!!");
    masterdS.RebootRequired = 1;
    exit(0);    /* will call masterdExitHandler after other cleanups */
}

#if GATEWAY_TR069
/* ev69 callbacks */
enum mibErr masterdEv69Save(unsigned JobNumber, const char *TextValue)
{
    /* This is called in mib JobStart context and can set config values */
    mibObjectHandle Object = mibobj(
        gwmibObjects.InternetGatewayDevice.XATHCOMInternal.XATHCOMEventQ);
    return mibManagerConfigSetFromText(JobNumber, Object, TextValue);
}
const char *masterdEv69Restore(void)
{
    mibObjectHandle Object = mibobj(
        gwmibObjects.InternetGatewayDevice.XATHCOMInternal.XATHCOMEventQ);
    return mibObjectTextGet(Object);
}
/*private*/ const struct ev69Storage masterdEv69Storage = {
    .Save = masterdEv69Save,
    .Restore = masterdEv69Restore,
};
#endif



/* For debugging support, check environmental variables
*/
/*private*/ void masterdParseEnv(void)
{
    char *Var;
    /* MASTERD_INIT_ONLY -- set bit set of inits to do from hex number
    */
    Var = getenv("MASTERD_INIT_ONLY");
    if (Var) {
        masterdS.InitList = strtoul(Var, NULL, 16);
    }
    /* MASTERD_INIT_SKIP -- bits set in hex number are cleared from init list,
    *   causing those inits to be skipped.
    */
    Var = getenv("MASTERD_INIT_SKIP");
    if (Var) {
        masterdS.InitList &= ~strtoul(Var, NULL, 16);
    }
    return;
}


/*private*/ void masterdParseArgs(char **argv)
{
    char *Arg;

    masterdS.SaveArgv = argv;   /* save for future re-exec */
    argv++;     /* skip program name */
    while ((Arg = *argv++) != NULL) {
        if (!strcmp(Arg, "--daemonize")) {
            masterdS.DoDaemonize = 1;
        } else
        if (Arg[0] == '-' && Arg[1] == 'w') {
            /* fork and watch for child (respawning)... */
            /* or followed by name of program to exec instead of respawn,
            *   e.g.:  -wreboot
            */
            masterdS.DoWatch = Arg+2;   /* empty or name of program to exec */
        } else
        if (!strcmp(Arg, "-d")) {
            if ((Arg = *argv++) == NULL) {
                masterdDebug(DBGERR, "-d requires arg");
                exit(1);
            }
            dbgModuleLevelsFromString(Arg);
            masterdDebug(DBGDEBUG, "Option -d %s", Arg);
        } else {
            masterdDebug(DBGERR, "INVALID ARG: %s", Arg);
            exit(1);
        }
    }
    return;
}

#ifdef POWER_ON_LED
struct evloopTimeout PowerOnTimer;
void PowerOnTimerHandler(void *Cookie)
{
    FILE *F = fopen("/proc/simple_config/power_on_finish", "w");
    if (F) {
        fprintf(F, "1");
        fclose(F);
    } 
}
void PowerOnFinish(void)
{
    evloopTimeoutCreate(&PowerOnTimer, "PowerOnTimer", PowerOnTimerHandler, NULL);
    evloopTimeoutRegister(&PowerOnTimer, 10, 0); /* delay for 10s */
}
#else
void PowerOnFinish(void){}
#endif

/*
 * Entry point of masterd program
 */
int main(int argc, char **argv)
{
    masterdS.InitList = ~0;     /* default, call all inits compiled in */

    /* Make sure our exit handler is installed first in list, so it will
     *  be called last.
     */
    atexit(masterdExitHandler);

    /* Make sure our debug options are set before any debugging! */
    dbgInit1(&masterdDbgInitOptions);

    /* Register for debug messages from this file */
    masterdS.DebugModule = dbgModuleFind("masterd");

    masterdDebug(DBGDEBUG, "Entering main of masterd executive program");

    /* Look at misc. environmental arguments */
    masterdParseEnv();

    /* Now we can look at arguments */
    masterdParseArgs(argv);

    if (masterdS.DoDaemonize && masterdS.DoWatch) {
        masterdDebug(DBGERR, "FATAL: cannot use both --daemonize and -w");
        exit(1);
    }

    if (masterdS.DoWatch) {
        dbgProgramNameSet("MSTW");      /* "master watch " */
        for (;;) {
            int Status;
            int GotPid;
            masterdDebug(DBGINFO, "Watch option: forking child");
            errno = 0;
            masterdS.DoWatchPid = fork();
            if (masterdS.DoWatchPid < 0) {
                masterdDebug(DBGERR, "fork failure errno %d", errno);
                exit(1);
            }
            if (masterdS.DoWatchPid == 0) {
                /* Child */
                argv[1] = NULL;   /* for debug, may show up in "ps" command? */
                dbgProgramNameSet("MSTR");      /* back to MSTR */
                /* Start a new process group so that we can kill entire
                *       process group on termination of child masterd.
                */
                setpgid(0/*self*/, 0/*set process group to self pid*/);
                break;  /* do masterd */
            }
            /* Here for parent */
            errno = 0;
            while ((GotPid = wait(&Status)) != masterdS.DoWatchPid) {
                masterdDebug(DBGDEBUG, "Wait ret %d w/ status 0x%x errno %d",
                    GotPid, Status, errno);
            }
            masterdDebug(DBGERR, 
                "Watch option: child pid=%d done w/ status 0x%x", 
                masterdS.DoWatchPid, Status);
            /* Kill any grandchild processes */
            kill(-masterdS.DoWatchPid, SIGKILL);  /* negative to kill process group! */
            masterdS.DoWatchPid = 0;
            sleep(3);   /* prevent overly rapid cycling on repeated failure */
            if (*masterdS.DoWatch) {
                /* is name of program to exec */
                masterdDebug(DBGINFO, "Exec %s", masterdS.DoWatch);
                execlp(masterdS.DoWatch, masterdS.DoWatch, NULL);
                masterdDebug(DBGERR, "That failed; try reboot instead");
                execlp("reboot", "reboot", NULL);
                masterdDebug(DBGERR, "That failed; keep going instead");
            }
        }
    } else

   	if (masterdS.DoDaemonize) {
        if (daemon(0,0)) {
            perror("daemon");
            exit(1);
        }
    }

    /* Handle signals by exiting (so that cleanups can be called) */
    signalExitInit();

    /* Connect our application MIB table with the generic mib code */
    mibInit(&gwmibMibTable);

    /* Provide mib reboot service */
    mibRebootCBSet(masterdRebootHandlerFromMib);

    /* Miscellaneous library initalizations */
    serviceInit();
    #if GATEWAY_TR069
    /* Note: use of ev69 does NOT imply that we support TR-069 */
    ev69StorageInstall(&masterdEv69Storage);
    #endif
    #if GATEWAY_NETGET_HTTPS && GATEWAY_FILEXFER
    /* Tell filexfer where to find SSL certificates */
    filexferCertificateObjectInstall(mibobj(
        gwmibObjects.InternetGatewayDevice.ManagementServer.XATHCOMCertificate));
    #endif
    #if GATEWAY_FILEXFER_STORE
    /* non-volatile storage of file xfer queue: */
    filexferStoreInit();
    /* Note: use of settimeServiceProvideGet() does not require
    *   that we actually initialize/run settime service.
    */
    #if GATEWAY_TIME
    filexferTimeServiceProvideSet(settimeServiceProvideGet());
    #endif
    #endif

    /* Bring up our service plugins IN ORDER OF INCREASING DEPENDENCY */
    #if GATEWAY_FIRMWARE
    if ((masterdS.InitList & (1<<masterdInit_firmwareInit)) != 0)
        firmwareInit();
    #endif
    #if GATEWAY_SYSLOG
    if ((masterdS.InitList & (1<<masterdInit_syslogInit)) != 0)
        syslogInit();
    #endif
    if ((masterdS.InitList & (1<<masterdInit_wanInit)) != 0)
        wanInit();
    if ((masterdS.InitList & (1<<masterdInit_lanInit)) != 0)
        lanInit();
    #if !GATEWAY_NO_WLAN
    if ((masterdS.InitList & (1<<masterdInit_wlanInit)) != 0)
        wlanInit();
    #endif // !GATEWAY_NO_WLAN
    if ((masterdS.InitList & (1<<masterdInit_broutingInit)) != 0)
        broutingInit();
    #if GATEWAY_PPPOE_PROXY
    if ((masterdS.InitList & (1<<masterdInit_pppoeproxyInit)) != 0)
        pppoeproxyInit();
    #endif
    #if GATEWAY_IGMP
    if ((masterdS.InitList & (1<<masterdInit_igmpInit)) != 0)
	igmpInit();
#ifdef GATEWAY_IPV6_MODULE
#if GATEWAY_ICMPV6
    icmpv6Init();
#endif
#endif //GATEWAY_IPV6_MODULE
    #endif
    #if !GATEWAY_NO_WLAN
    if ((masterdS.InitList & (1<<masterdInit_wlansecInit)) != 0)
        wlansecInit();
    #endif      // !GATEWAY_NO_WLAN
    #if GATEWAY_TIME
    if ((masterdS.InitList & (1<<masterdInit_timezoneInit)) != 0)
        timezoneInit();
    if ((masterdS.InitList & (1<<masterdInit_settimeInit)) != 0)
        settimeInit();
    #endif
    #if GATEWAY_DHCP_SERVER
    if ((masterdS.InitList & (1<<masterdInit_dhcpdInit)) != 0)
        dhcpdInit();
    #endif
    #if GATEWAY_SERVICE_MANAGE
    if ((masterdS.InitList & (1<<masterdInit_serviceManageInit)) != 0)
        serviceManageInit();
    #endif
    #if GATEWAY_USB
    if ((masterdS.InitList & (1<<masterdInit_usbInit)) != 0)
        usbInit();
    #endif
    #if GATEWAY_QOS
	if ((masterdS.InitList & (1<<masterdInit_qosInit)) != 0)
        qosInit();
    #endif
    #if GATEWAY_UPNP
	if ((masterdS.InitList & (1<<masterdInit_upnpInit)) != 0)
        upnpInit();
    #endif
    #if GATEWAY_ROUTING
	if ((masterdS.InitList & (1<<masterdInit_routerInit)) != 0)
        routerInit();
    #endif
    #if GATEWAY_DEV_INFO
    if ((masterdS.InitList & (1<<masterdInit_devinfoInit)) != 0)
        devinfoInit();
    #endif
    #if GATEWAY_PASSWORD
    if ((masterdS.InitList & (1<<masterdInit_passwordInit)) != 0)
        passwordInit();
    #endif
    #if GATEWAY_DIAG
	//fix me,this module don't work now
    if((masterdS.InitList & (1 <<masterdInit_diagInit)) != 0)
        diagInit();
    #endif
    #if GATEWAY_PHONE
    if ((masterdS.InitList & (1<<masterdInit_phoneInit)) != 0)
        phoneInit();
    #endif
    #if GATEWAY_OSPFD
	        ospfdInit();
    #endif

    /* Bring up our manager plugins in any order except nvs FIRST */
    #if GATEWAY_NVS_MTD
    if ((masterdS.InitList & (1<<masterdInit_nvsInit)) != 0)
        nvsmtdInit();        /* Nonvolatile storage FIRST! */
    #else       // GATEWAY_NVS_MTD
    if ((masterdS.InitList & (1<<masterdInit_nvsInit)) != 0)
        nvsInit(&masterdNvsOptions);        /* Nonvolatile storage FIRST! */
    #endif      // GATEWAY_NVS_MTD
    #if GATEWAY_SWITCH_QOS
    if((masterdS.InitList & (1 <<masterdInit_switchqosInit)) != 0)
        switchqosInit();
    #endif
    if ((masterdS.InitList & (1<<masterdInit_mibcliInit)) != 0)
        mibcliInit();       /* a manager for debugging */
    /* mibsh: CLI for controlling mib (mib manager capability) */
    if ((masterdS.InitList & (1<<masterdInit_mibshInit)) != 0)
        mibshInit(0/*0 = port from env. variable or default*/);
    #if GATEWAY_TR069
    if ((masterdS.InitList & (1<<masterdInit_tr069shInit)) != 0)
        tr069shInit();
    #endif  // GATEWAY_NO_TR069

    #if GATEWAY_CTCMW
    if ((masterdS.InitList & (1<<masterdInit_ctcmwInit)) != 0)
        ctcmwInit();
    #endif  // GATEWAY_NO_CTCMW

    #if GATEWAY_LLTD
	if ((masterdS.InitList & (1<<masterdInit_lltdInit)) != 0)
        lltdInit();
    #endif
    #if GATEWAY_PROFILE_PLC
	if ((masterdS.InitList & (1<<masterdInit_plcInit)) != 0)
	plcInit();
    #endif
    #if GATEWAY_ART
        artInit();
    #endif
   
#ifdef GATEWAY_IPV6_MODULE    
    #if GATEWAY_RADVD
        radvdInit();
    #endif

    #if GATEWAY_DHCP6S
        dhcp6sInit();
    #endif    

    #if GATEWAY_PPPDHCP6C
        pppdhcp6cInit();
    #endif


    #if GATEWAY_TSPC
    tspcInit();
    #endif    

    #if GATEWAY_IVI
    iviInit();
    #endif       
#endif //GATEWAY_IPV6_MODULE

    #if GATEWAY_PROFILE_HY
    hyInit();
    #endif

    #if GATEWAY_WSPLC
    wsplcInit();
    #endif

    /* Optional features: */
    /* Add debugging shell capability (includes mib manager capability) */
    if ((masterdS.InitList & (1<<masterdInit_cshInit)) != 0)
        cshInit(0/*0 = port from env. variable or default*/);

    PowerOnFinish();

    /* Main event loop waits for things to happen...
     * is the ONLY place we should EVER wait for anything to happen.
     */
    masterdDebug(DBGDEBUG, "Entering evloopRun");
    evloopRun();

    /* Probably won't get here... */
    masterdDebug(DBGDEBUG, "Leaving masterd executive program");
    return 0;
}
