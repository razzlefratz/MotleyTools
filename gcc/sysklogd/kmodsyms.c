/*====================================================================*
 *   
 *   kmodsyms.c - functions for building symbol lookup tables for klogd
 *   
 *   Copyright (c) 1995, 1996  Dr. G.W. Wettstein <greg@wind.rmcc.com>
 *   Copyright (c) 1996 Enjellic Systems Development
 *   
 *   This file is part of the sysklogd package, a kernel and system log daemon.
 *   
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *   
 *--------------------------------------------------------------------*/

/*====================================================================*
 *   
 * This file implements functions which are useful for building
 * a symbol lookup table based on the in kernel symbol table
 * maintained by the Linux kernel.
 *
 * Proper logging of kernel panics generated by loadable modules
 * tends to be difficult.  Since the modules are loaded dynamically
 * their addresses are not known at kernel load time.  A general
 * protection fault (Oops) cannot be properly deciphered with 
 * classic methods using the static symbol map produced at link time.
 *
 * One solution to this problem is to have klogd attempt to translate
 * addresses from module when the fault occurs.  By referencing the
 * the kernel symbol table proper resolution of these symbols is made
 * possible.
 *
 * At least that is the plan.
 *
 * Wed Aug 21 09:20:09 CDT 1996:  Dr. Wettstein
 *	The situation where no module support has been compiled into a
 *	kernel is now detected.  An informative message is output indicating
 *	that the kernel has no loadable module support whenever kernel
 *	module symbols are loaded.
 *
 *	An informative message is printed indicating the number of kernel
 *	modules and the number of symbols loaded from these modules.
 *
 * Sun Jun 15 16:23:29 MET DST 1997: Michael Alan Dorman
 *	Some more glibc patches made by <mdorman@debian.org>.
 *
 * Sat Jan 10 15:00:18 CET 1998: Martin Schulze <joey@infodrom.north.de>
 *	Fixed problem with klogd not being able to be built on a kernel
 *	newer than 2.1.18.  It was caused by modified structures
 *	inside the kernel that were included.  I have worked in a
 *	patch from Alessandro Suardi <asuardi@uninetcom.it>.
 *
 * Sun Jan 25 20:57:34 CET 1998: Martin Schulze <joey@infodrom.north.de>
 *	Another patch for Linux/alpha by Christopher C Chimelis
 *	<chris@classnet.med.miami.edu>.
 *
 * Thu Mar 19 23:39:29 CET 1998: Manuel Rodrigues <pmanuel@cindy.fe.up.pt>
 *	Changed lseek() to llseek() in order to support > 2GB address
 *	space which provided by kernels > 2.1.70.
 *
 * Mon Apr 13 18:18:45 CEST 1998: Martin Schulze <joey@infodrom.north.de>
 *	Removed <sys/module.h> as it's no longer part of recent glibc
 *	versions.  Added prototyp for llseek() which has been
 *	forgotton in <unistd.h> from glibc.  Added more log
 *	information if problems occurred while reading a system map
 *	file, by submission from Mark Simon Phillips <M.S.Phillips@nortel.co.uk>.
 *
 * Sun Jan  3 18:38:03 CET 1999: Martin Schulze <joey@infodrom.north.de>
 *	Corrected return value of AddModule if /dev/kmem can't be
 *	loaded.  This will prevent klogd from segfaulting if /dev/kmem
 *	is not available.  Patch from Topi Miettinen <tom@medialab.sonera.net>.
 *
 * Tue Sep 12 23:11:13 CEST 2000: Martin Schulze <joey@infodrom.ffis.de>
 *	Changed llseek() to lseek64() in order to skip a libc warning.
 *   
 *--------------------------------------------------------------------*/

#ifndef KMODSYMS_SOURCE
#define KMODSYMS_SOURCE

/*====================================================================*
 *   system header files;
 *--------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <syslog.h>
#include <malloc.h>
#include <unistd.h>
#include <signal.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <paths.h>
#include <linux/version.h>
#include <error.h>
#include <errno.h>

/*====================================================================*
 *   custom header files;
 *--------------------------------------------------------------------*/

#include "../sysklogd/ksyms.h"
#include "../linux/syslog.h"

#if !defined(__GLIBC__)

/*
 * The following bit uses some kernel/library magic to product what
 * looks like a function call to user level code.  This function is
 * actually a system call in disguise.  The purpose of the getsyms
 * call is to return a current copy of the in-kernel symbol table.
 */

#include <linux/time.h>
#include <linux/module.h>
#define __LIBRARY__
#include <linux/unistd.h>
#define __NR_getsyms __NR_get_kernel_syms

_syscall1 (int, getsyms, struct kernel_sym *, syms); 

#undef __LIBRARY__

extern int getsyms (struct kernel_sym *); 

/* __GLIBC__ */

#else 

extern __off64_t lseek64 __P ((int __fd, __off64_t __offset, int __whence)); 
extern int get_kernel_syms __P ((struct kernel_sym * __table)); 

/* __GLIBC__ */

#define getsyms get_kernel_syms
#endif 

/*====================================================================*
 *   program variables;
 *--------------------------------------------------------------------*/

static int num_modules = 0; 
struct _module_ * symbols_modules = (struct _module_ *) (0); 
static int have_modules = 0; 

#if defined(TEST)

static int debugging = 1; 

#else

extern int debugging; 

#endif

/*====================================================================*
 *   program vunctions;
 *--------------------------------------------------------------------*/

static int AddSymbol (unsigned long address, char * symbol, struct _module_ * module); 
static int AddModule (unsigned long address, char * symbol); 
static void FreeModules (); 
static int symsort (void const * p1, void const * p2); 

/*====================================================================*
 *
 * Function:	InitMsyms
 *
 * Purpose:	This function is responsible for building a symbol
 *		table which can be used to resolve addresses for
 *		loadable modules.
 *
 * Arguements:	Void
 *
 * Return:	A boolean return value is assumed.
 *
 *		A false value indicates that something went wrong.
 *
 *		True if loading is successful.
 *
 *--------------------------------------------------------------------*/

extern int InitMsyms () 

{ 
	auto int rtn, 
	tmp; 
	auto struct kernel_sym * kmodule_symbol, 
	* p; 

/*
 * Initialize the kernel module symbol table. 
 */

	FreeModules (); 

/*
 * The system call which returns the kernel symbol table has
 * essentialy two modes of operation.  Called with a null pointer
 * the system call returns the number of symbols defined in the
 * the table.
 *
 * The second mode of operation is to pass a valid pointer to
 * the call which will then load the current symbol table into
 * the memory provided.
 *
 * Returning the symbol table is essentially an all or nothing
 * proposition so we need to pre-allocate enough memory for the
 * complete table regardless of how many symbols we need.
 *
 * Bummer.
 */

	if ((rtn = getsyms ((struct kernel_sym *) 0)) < 0) 
	{ 
		if (errno == ENOSYS) Syslog (SYSLOG_INFO, "No module symbols loaded - kernel modules not enabled.\n"); 
		else Syslog (LOG_ERR, "Error loading kernel symbols - %s\n", strerror (errno)); 
		return (0); 
	} 
	if (debugging) fprintf (stderr, "Loading kernel module symbols - Size of table: %d\n", rtn); 
	kmodule_symbol = (struct kernel_sym *) malloc (rtn * sizeof (struct kernel_sym)); 
	if (kmodule_symbol == (struct kernel_sym *) 0) 
	{ 
		Syslog (LOG_WARNING, " Failed memory allocation for kernel symbol table.\n"); 
		return (0); 
	} 
	if ((rtn = getsyms (kmodule_symbol)) < 0) 
	{ 
		Syslog (LOG_WARNING, "Error reading kernel symbols - %s\n", strerror (errno)); 
		return (0); 
	} 

/*
 * Build a symbol table compatible with the other one used by
 * klogd.
 */

	tmp = rtn; 
	p = kmodule_symbol; 
	while (tmp--) 
	{ 
		if (!AddModule (p->value, p->name)) 
		{ 
			Syslog (LOG_WARNING, "Error adding kernel module table " "entry.\n"); 
			free (kmodule_symbol); 
			return (0); 
		} 
		++ p; 
	} 

/*
 * Sort the symbol tables in each module. 
 */

	for (rtn = tmp = 0; tmp < num_modules; ++ tmp) 
	{ 
		rtn += symbols_modules [tmp].num_syms; 
		if (symbols_modules [tmp].num_syms < 2) continue; 
		qsort (symbols_modules [tmp].symbols, symbols_modules [tmp].num_syms, sizeof (struct module_symbol), symsort); 
	} 
	if (rtn == 0) Syslog (SYSLOG_INFO, "No module symbols loaded."); 
	else Syslog (SYSLOG_INFO, "Loaded %d %s from %d module%s", rtn, (rtn == 1)? "symbol": "symbols", num_modules, (num_modules == 1)? ".": "s."); 
	free (kmodule_symbol); 
	return (1); 
} 

/*====================================================================*
 *   
 * Function:	LookupModuleSymbol
 *
 * Purpose:	Find the symbol which is related to the given address from
 *		a kernel module.
 *
 * Arguements:	(long int) value, (struct symbol *) sym
 *
 *		value:->	The address to be located.
 * 
 *		sym:->		A pointer to a structure which will be
 *				loaded with the symbol's parameters.
 *
 * Return:	(char *)
 *
 *		If a match cannot be found a diagnostic string is printed.
 *		If a match is found the pointer to the symbolic name most
 *		closely matching the address is returned.
 *--------------------------------------------------------------------*/

extern char const * LookupModuleSymbol (unsigned long address, struct symbol * symbol) 

{ 
	int nmod; 
	int nsym; 
	struct module_symbol * last; 
	struct _module_ * module; 
	symbol->size = 0; 
	symbol->offset = 0; 
	if (num_modules == 0) return ((char *) 0); 
	for (nmod = 0; nmod < num_modules; ++ nmod) 
	{ 
		module = & symbols_modules [nmod]; 

/*
 * Run through the list of symbols in this module and
 * see if the address can be resolved.
 */

		for (nsym = 1, last = & module->symbols [0]; nsym < module->num_syms; ++ nsym) 
		{ 
			if (module->symbols [nsym].value > address) 
			{ 
				symbol->offset = address - last->value; 
				symbol->size = module->symbols [nsym].value - last->value; 
				return (last->name); 
			} 
			last = & module->symbols [nsym]; 
		} 

/*
 * At this stage of the game we still cannot give up the
 * ghost.  There is the possibility that the address is
 * from a module which has no symbols registered with
 * the kernel.  The solution is to compare the address
 * against the starting address and extent of the module
 * If it is in this range we can at least return the
 * name of the module.
 */

#if LINUX_VERSION_CODE >= 0x20112

		if (address >= module->module_info.addr && address <= (module->module_info.addr + module->module.size * 4096)) 

#else

		if ((void *) (address) >= module->module.addr && (void *) (address) <= (module->module.addr + module->module.size * 4096)) 

#endif

		{ 

/*
 * A special case needs to be checked for.  The above
 * conditional tells us that we are within the
 * extant of this module but symbol lookup has
 * failed.
 *
 * We need to check to see if any symbols have
 * been defined in this module.  If there have been
 * symbols defined the assumption must be made that
 * the faulting address lies somewhere beyond the
 * last symbol.  About the only thing we can do
 * at this point is use an offset from this
 * symbol.
 */

			if (module->num_syms > 0) 
			{ 
				last = & module->symbols [module->num_syms - 1]; 

#if LINUX_VERSION_CODE < 0x20112

				symbol->size = (int) module->module.addr + (module->module.size * 4096) - address; 

#else

				symbol->size = (int) module->module_info.addr + (module->module.size * 4096) - address; 

#endif

				symbol->offset = address - last->value; 
				return (last->name); 
			} 

/*
 * There were no symbols defined for this module.
 * Return the module name and the offset of the
 * faulting address in the module.
 */

			symbol->size = module->module.size * 4096; 

#if LINUX_VERSION_CODE < 0x20112

			symbol->offset = (void *) (address) - module->module.addr; 

#else

			symbol->offset = (address) - module->module_info.addr; 

#endif

			return (module->name); 
		} 
	} 

/*
 * It has been a hopeless exercise. 
 */

	return ((char *) 0); 
} 

/*
 * Setting the -DTEST define enables the following code fragment to
 * be compiled.  This produces a small standalone program which will
 * dump the current kernel symbol table.
 */

/*====================================================================*
 *   
 *   int AddModule (unsigned long address, char *symbol);
 *
 * Purpose:	This function is responsible for adding a module to
 *		the list of currently loaded modules.
 *
 * Arguements:	(unsigned long) address, (char *) symbol
 *
 *		address:->	The address of the module.
 *
 *		symbol:->	The name of the module.
 *
 * Return:	int
 *--------------------------------------------------------------------*/

static int AddModule (unsigned long address, char * symbol) 

{ 
	auto int memfd; 
	auto struct _module_ * module; 

/*
 * Return if we have loaded the modules. 
 */

	if (have_modules) return (1); 

/*
 * The following section of code is responsible for determining
 * whether or not we are done reading the list of modules.
 */

	if (symbol [0] == '#') 
	{ 
		if (symbol [1] == '\0') 
		{ 

/*
 * A symbol which consists of a # sign only
 * signifies a a resident kernel segment.  When we
 * hit one of these we are done reading the
 * module list.
 */

			have_modules = 1; 
			return (1); 
		} 

/*
 * Allocate space for the module. 
 */

		symbols_modules = (struct _module_ *) (realloc (symbols_modules, (num_modules + 1) * sizeof (struct _module_))); 
		if (symbols_modules == (struct _module_ *) 0) 
		{ 
			Syslog (LOG_WARNING, "Cannot allocate Module array.\n"); 
			return (0); 
		} 
		module = & symbols_modules [num_modules]; 
		if ((memfd = open ("/dev/kmem", O_RDONLY)) < 0) 
		{ 
			Syslog (LOG_WARNING, "Error opening /dev/kmem\n"); 
			return (0); 
		} 
		if (lseek64 (memfd, address, SEEK_SET) < 0) 
		{ 
			Syslog (LOG_WARNING, "Error seeking in /dev/kmem\n"); 
			Syslog (LOG_WARNING, "Symbol %s, address %08x\n", symbol, address); 
			return (0); 
		} 
		if (read (memfd, (char *) & symbols_modules [num_modules].module, sizeof (struct module)) < 0) 
		{ 
			Syslog (LOG_WARNING, "Error reading module " "descriptor.\n"); 
			return (0); 
		} 
		close (memfd); 

/*
 * Save the module name. 
 */

		module->name = (char *) malloc (strlen (& symbol [1]) + 1); 
		if (module->name == (char *) 0) return (0); 
		strcpy (module->name, & symbol [1]); 
		module->num_syms = 0; 
		module->symbols = (struct module_symbol *) 0; 
		++ num_modules; 
		return (1); 
	} 
	else 
	{ 
		if (num_modules > 0) module = & symbols_modules [num_modules - 1]; 
		else module = & symbols_modules [0]; 
		AddSymbol (address, symbol, module); 
	} 
	return (1); 
} 

/*====================================================================*
 *   
 *   static int AddSymbol (unsigned long address, char *symbol, struct _module_ *module);
 *
 * Purpose:	This function is responsible for adding a symbol name
 *		and its address to the symbol table.
 *
 * Arguements:	(struct _module_ *) mp, (unsigned long) address, (char *) symbol
 *
 *		mp:->	A pointer to the module which the symbol is
 *			to be added to.
 *
 *		address:->	The address of the symbol.
 *
 *		symbol:->	The name of the symbol.
 *
 * Return:	int
 *
 *		A boolean value is assumed.  True if the addition is
 *		successful.  False if not.
 *--------------------------------------------------------------------*/

static int AddSymbol (unsigned long address, char * symbol, struct _module_ * module) 

{ 
	auto int tmp; 

/*
 * Allocate space for the symbol table entry. 
 */

	module->symbols = (struct module_symbol *) realloc (module->symbols, (module->num_syms + 1) * sizeof (struct module_symbol)); 
	if (module->symbols == (struct module_symbol *) 0) return (0); 

/*
 * Then the space for the symbol. 
 */

	tmp = strlen (symbol); 
	tmp += (strlen (module->name) + 1); 
	module->symbols [module->num_syms].name = (char *) malloc (tmp + 1); 
	if (module->symbols [module->num_syms].name == (char *) 0) return (0); 
	memset (module->symbols [module->num_syms].name, '\0', tmp + 1); 

/*
 * Stuff interesting information into the module. 
 */

	module->symbols [module->num_syms].value = address; 
	strcpy (module->symbols [module->num_syms].name, module->name); 
	strcat (module->symbols [module->num_syms].name, ":"); 
	strcat (module->symbols [module->num_syms].name, symbol); 
	++ module->num_syms; 
	return (1); 
} 

/*====================================================================*
 *
 *   void FreeModules ();
 *
 * Purpose:	This function is used to free all memory which has been
 *		allocated for the modules and their symbols.
 *
 * Arguements:	None specified.
 *
 * Return:	void
 *--------------------------------------------------------------------*/

static void FreeModules () 

{ 
	int nmods; 
	int nsyms; 
	struct _module_ * module; 

/*
 * Check to see if the module symbol tables need to be cleared. 
 */

	have_modules = 0; 
	if (num_modules) 
	{ 
		for (nmods = 0; nmods < num_modules; ++ nmods) 
		{ 
			module = & symbols_modules [nmods]; 
			if (module->num_syms == 0) continue; 
			for (nsyms = 0; nsyms < module->num_syms; ++ nsyms) 
			{ 
				free (module->symbols [nsyms].name); 
			} 
			free (module->symbols); 
		} 
		free (symbols_modules); 
		symbols_modules = (struct _module_ *) (0); 
		num_modules = 0; 
	} 
	return; 
} 

/*====================================================================*
 *
 *   static int symsort (void const *p1, void const *p2);
 *
 *
 *
 *--------------------------------------------------------------------*/

static int symsort (void const * p1, void const * p2) 

{ 
	const struct module_symbol * symbol1 = p1; 
	const struct module_symbol * symbol2 = p2; 
	if (symbol1->value < symbol2->value) 
	{ 
		return (- 1); 
	} 
	if (symbol1->value > symbol2->value) 
	{ 
		return (1); 
	} 
	return (0); 
} 

/*====================================================================*
 *
 *   void Syslog (int priority, char *fmt, ...);
 *   
 *   
 *--------------------------------------------------------------------*/

#ifdef TEST

static void Syslog (int priority, char * fmt, ...) 

{ 
	va_list ap; 
	va_start (ap, fmt); 
	fprintf (stdout, "Pr: %d, ", priority); 
	vfprintf (stdout, fmt, ap); 
	va_end (ap); 
	fputc ('\n', stdout); 
	return; 
} 

#endif

/*====================================================================*
 *
 *   int main (int argc, char *argv[]);
 *
 *
 *
 *--------------------------------------------------------------------*/

#ifdef TEST

#include <stdarg.h>

int main (int argc, char * argv []) 

{ 
	auto int lp, 
	syms; 
	if (!InitMsyms ()) 
	{ 
		fprintf (stderr, "Cannot load module symbols.\n"); 
		return (1); 
	} 
	printf ("Number of modules: %d\n\n", num_modules); 
	for (lp = 0; lp < num_modules; ++ lp) 
	{ 
		printf ("Module #%d = %s, Number of symbols = %d\n", lp + 1, symbols_modules [lp].name, symbols_modules [lp].num_syms); 
		for (syms = 0; syms < symbols_modules [lp].num_syms; ++ syms) 
		{ 
			printf ("\tSymbol #%d\n", syms + 1); 
			printf ("\tName: %s\n", symbols_modules [lp].symbols [syms].name); 
			printf ("\tAddress: %lx\n\n", symbols_modules [lp].symbols [syms].address); 
		} 
	} 
	FreeModules (); 
	return (0); 
} 

#endif

#endif



